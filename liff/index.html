<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ibon æ¼”å”±æœƒæ´»å‹•æ¸…å–®</title>
  <script src="https://static.line-scdn.net/liff/edge/versions/2.23.1/sdk.js"></script>
  <style>
    :root {
      color-scheme: light;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, "Noto Sans TC", sans-serif;
      margin: 16px;
      background: #f7f8fa;
      color: #222;
    }
    header {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 16px;
    }
    header h1 {
      margin: 0;
      font-size: 1.4rem;
      font-weight: 700;
      color: #1a237e;
    }
    .controls {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    }
    .controls label {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 600;
    }
    input[type="number"] {
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid #c5c9d3;
      width: 100px;
      font-size: 1rem;
    }
    button {
      border: none;
      border-radius: 999px;
      padding: 8px 16px;
      font-size: 0.95rem;
      cursor: pointer;
      transition: transform 0.12s ease, box-shadow 0.12s ease;
      background: #ffffff;
      border: 1px solid #d0d4e4;
    }
    button.primary {
      background: #3949ab;
      border-color: #3949ab;
      color: #fff;
    }
    button.secondary {
      background: #f4f5fb;
    }
    button.danger {
      background: #ffe5e5;
      border-color: #f5b7b1;
      color: #c0392b;
    }
    button:disabled {
      opacity: 0.65;
      cursor: not-allowed;
      box-shadow: none;
    }
    button:not(:disabled):active {
      transform: scale(0.98);
    }
    #out {
      margin-bottom: 12px;
      color: #556;
      min-height: 1.2rem;
    }
    .cards {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .card {
      background: #fff;
      border-radius: 16px;
      border: 1px solid #e0e4ef;
      box-shadow: 0 6px 16px rgba(31, 45, 90, 0.08);
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .card .title {
      font-size: 1.05rem;
      font-weight: 700;
      color: #1f2d5a;
    }
    .card img {
      width: 100%;
      max-height: 220px;
      object-fit: cover;
      border-radius: 14px;
      background: #f0f1f6;
    }
    .meta span {
      display: block;
      color: #444;
      line-height: 1.5;
    }
    .links {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    }
    .links a {
      color: #1a73e8;
      text-decoration: none;
      font-weight: 600;
    }
    .links a:hover {
      text-decoration: underline;
    }
    .status-text {
      font-size: 0.95rem;
      color: #2f4858;
    }
    .watch-state {
      font-size: 0.9rem;
      color: #59617a;
    }
    .buttons {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 4px;
    }
    .feedback {
      font-size: 0.9rem;
      color: #1e5ba5;
      min-height: 1rem;
    }
    .empty-message {
      text-align: center;
      padding: 32px 12px;
      color: #6f7a90;
      border-radius: 12px;
      background: rgba(57, 73, 171, 0.08);
    }
  </style>
</head>
<body>
  <header>
    <h1>ibon æ¼”å”±æœƒæ´»å‹•æ¸…å–®</h1>
    <div class="controls">
      <label for="sec">ç›£çœ‹ç§’æ•¸ï¼š<input id="sec" type="number" min="15" step="1" value="30" /></label>
      <button id="reload" class="secondary" type="button">é‡æ–°æ•´ç†æ¸…å–®</button>
    </div>
  </header>

  <div id="out" class="hint">è¼‰å…¥æ´»å‹•æ¸…å–®ä¸­â€¦</div>

  <div id="list" class="cards"></div>

  <script>
    window.LIFF_CONFIG = {
      liffId: "2008066018-EMmpzmKo",
      limit: 20,
    };
  </script>
  <script>
    (function(){
      const CONFIG = window.LIFF_CONFIG || {};
      const LIFF_ID = CONFIG.liffId || "";
      const API_ROOT = CONFIG.apiRoot || "/api/liff";
      const STATUS_API = CONFIG.statusApi || "/liff/watch_status";
      const LIMIT = Math.max(1, Math.min(50, Number(CONFIG.limit) || 20));
      const PLACEHOLDER_IMAGE = CONFIG.placeholderImage ||
        "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='640' height='360'><rect width='640' height='360' fill='%23f0f1f6'/><text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' font-size='28' font-family='Arial' fill='%23896a9'>æš«ç„¡åœ–ç‰‡</text></svg>";

      const state = {
        chatId: null,
        statusMap: {},
        items: [],
        isClient: false,
        loading: false,
      };

      const elOut = document.getElementById("out");
      const elList = document.getElementById("list");
      const elReload = document.getElementById("reload");
      const elSec = document.getElementById("sec");

      function buildStatusLine(item){
        if (!item) return "æš«æ™‚è®€ä¸åˆ°å‰©é¤˜æ•¸ï¼ˆå¯èƒ½ç‚ºå‹•æ…‹è¼‰å…¥ï¼‰";
        if (typeof item.remain === "number" && Number.isFinite(item.remain)){
          return `å‰©é¤˜ ${item.remain} å¼µ`;
        }
        if (item.status_text){
          return item.status_text;
        }
        return "æš«æ™‚è®€ä¸åˆ°å‰©é¤˜æ•¸ï¼ˆå¯èƒ½ç‚ºå‹•æ…‹è¼‰å…¥ï¼‰";
      }

      function setStatus(text){
        if (elOut) elOut.textContent = text || "";
      }

      function ensureSec(v){
        const n = parseInt(v, 10);
        if (Number.isNaN(n) || n < 15) return 15;
        return n;
      }

      function canonicalUrl(url){
        try {
          const u = new URL(url);
          u.hash = "";
          u.searchParams.sort?.();
          return u.toString();
        } catch (e) {
          return url;
        }
      }

      function updateWatchState(url, data){
        const key = canonicalUrl(url);
        const entry = state.statusMap[key] || {};
        state.statusMap[key] = Object.assign({}, entry, data);
      }

      function createMetaLine(label, value){
        if (!value) return null;
        const span = document.createElement("span");
        span.textContent = `${label} ${value}`;
        return span;
      }

      function createCard(item, index){
        const card = document.createElement("article");
        card.className = "card";
        card.dataset.url = item.url || "";

        const title = document.createElement("div");
        title.className = "title";
        title.textContent = `${String(index + 1).padStart(2, "0")}. ${item.title || "æ´»å‹•"}`;
        card.appendChild(title);

        const img = document.createElement("img");
        const cover = item.image || item.image_url || item.cover || "";
        img.src = cover || PLACEHOLDER_IMAGE;

        img.alt = item.title || "æ´»å‹•åœ–ç‰‡";
        img.onerror = () => {
          if (img.src !== PLACEHOLDER_IMAGE) {
            img.src = PLACEHOLDER_IMAGE;
          }
        };
        card.appendChild(img);

        const meta = document.createElement("div");
        meta.className = "meta";

        const dateLine = createMetaLine("ğŸ“…", item.datetime || item.date_text || item.date || "");
        const placeLine = createMetaLine("ğŸ“", item.venue || item.place || "");
        const remainLine = (typeof item.remain === "number" && Number.isFinite(item.remain))
          ? createMetaLine("ğŸŸï¸ å‰©é¤˜", `${item.remain} å¼µ`)
          : null;
        if (dateLine) meta.appendChild(dateLine);
        if (placeLine) meta.appendChild(placeLine);
        if (remainLine) meta.appendChild(remainLine);

        card.appendChild(meta);

        const links = document.createElement("div");
        links.className = "links";
        if (item.url){
          const anchor = document.createElement("a");
          anchor.href = item.url;
          anchor.target = "_blank";
          anchor.rel = "noopener";
          anchor.textContent = "æ´»å‹•é é¢";
          links.appendChild(anchor);
        }
        card.appendChild(links);

        const statusText = document.createElement("div");
        statusText.className = "status-text";
        statusText.textContent = buildStatusLine(item);

        card.appendChild(statusText);

        const watchInfo = document.createElement("div");
        watchInfo.className = "watch-state";
        card.appendChild(watchInfo);

        const buttons = document.createElement("div");
        buttons.className = "buttons";

        const btnWatch = document.createElement("button");
        btnWatch.className = "primary btn-watch";
        btnWatch.type = "button";
        btnWatch.textContent = "âœ… é–‹å§‹ç›£çœ‹";
        btnWatch.addEventListener("click", () => handleWatch(item, card, statusText, watchInfo, feedback));
        buttons.appendChild(btnWatch);

        const btnStop = document.createElement("button");
        btnStop.className = "danger btn-stop";
        btnStop.type = "button";
        btnStop.textContent = "â›”ï¸ åœæ­¢ç›£çœ‹";

        btnStop.addEventListener("click", () => handleUnwatch(item, card, statusText, watchInfo, feedback));
        buttons.appendChild(btnStop);

        const btnQuick = document.createElement("button");
        btnQuick.className = "secondary btn-quick";
        btnQuick.type = "button";
        btnQuick.textContent = "ğŸ‘ å¿«é€ŸæŸ¥çœ‹";

        btnQuick.addEventListener("click", () => handleQuickCheck(item, card, statusText, feedback));
        buttons.appendChild(btnQuick);

        card.appendChild(buttons);

        const feedback = document.createElement("div");
        feedback.className = "feedback";
        card.appendChild(feedback);

        updateCardWatchInfo(item.url, watchInfo);
        return card;
      }

      function updateCardWatchInfo(url, watchInfo){
        if (!watchInfo) return;
        const key = canonicalUrl(url);
        const status = state.statusMap[key];
        if (status && status.taskId){
          watchInfo.textContent = status.enabled ? `ç‹€æ…‹ï¼šç›£çœ‹ä¸­ï½œä»»å‹™ ${status.taskId}` : `ç‹€æ…‹ï¼šä»»å‹™ ${status.taskId} å·²åœç”¨`;
        } else if (status && status.found){
          watchInfo.textContent = "ç‹€æ…‹ï¼šæ­¤æ´»å‹•å·²å»ºç«‹ä»»å‹™ä½†ç›®å‰æœªå•Ÿç”¨";
        } else {
          watchInfo.textContent = "";
        }
      }

      function setCardFeedback(feedbackNode, message){
        if (!feedbackNode) return;
        feedbackNode.textContent = message || "";
      }

      function setButtonsDisabled(card, disabled){
        card.querySelectorAll("button").forEach(btn => {
          btn.disabled = disabled;
        });
      }

      async function handleWatch(item, card, statusText, watchInfo, feedback){
        if (!item.url){
          alert("æ­¤æ´»å‹•æ²’æœ‰å¯ç”¨çš„ URLï¼Œç„¡æ³•ç›£çœ‹ã€‚");
          return;
        }
        if (!state.chatId){
          alert("å°šæœªå–å¾—èŠå¤©å®¤è­˜åˆ¥ï¼Œè«‹é‡æ–°é–‹å•Ÿ LIFF å†è©¦ä¸€æ¬¡ã€‚");
          return;
        }
        const sec = ensureSec(elSec ? elSec.value : 30);
        const payload = { chat_id: state.chatId, url: item.url, period: sec };
        const btn = card.querySelector(".btn-watch");
        const original = btn ? btn.textContent : "";
        if (btn) {
          btn.disabled = true;
          btn.textContent = "é€å‡ºä¸­â€¦";
        }
        setCardFeedback(feedback, "é€å‡ºç›£çœ‹è«‹æ±‚ä¸­â€¦");
        try {
          const res = await fetch(`${API_ROOT}/watch`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            credentials: "include",
            body: JSON.stringify(payload),
          });
          const body = await res.json();
          if (!res.ok || !body.ok){
            throw new Error(body.error || `HTTP ${res.status}`);
          }
          updateWatchState(item.url, { watching: true, enabled: true, taskId: body.task_id, found: true });
          updateCardWatchInfo(item.url, watchInfo);
          setCardFeedback(feedback, body.message || "å·²é–‹å§‹ç›£çœ‹ã€‚");

          if (body.detail){
            statusText.textContent = buildStatusLine({
              remain: body.detail.remain ?? body.detail.remaining,
              status_text: body.detail.status_text,
            });

          }
        } catch (err) {
          console.error("watch failed", err);
          alert(`é–‹å§‹ç›£çœ‹å¤±æ•—ï¼š${err.message || err}`);
          setCardFeedback(feedback, "é–‹å§‹ç›£çœ‹å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚");
        } finally {
          if (btn){
            btn.disabled = false;
            btn.textContent = original || "âœ… é–‹å§‹ç›£çœ‹";
          }
        }
      }

      async function handleUnwatch(item, card, statusText, watchInfo, feedback){
        if (!item.url){
          alert("æ­¤æ´»å‹•æ²’æœ‰å¯ç”¨çš„ URLã€‚");
          return;
        }
        if (!state.chatId){
          alert("å°šæœªå–å¾—èŠå¤©å®¤è­˜åˆ¥ï¼Œè«‹é‡æ–°é–‹å•Ÿ LIFF å†è©¦ä¸€æ¬¡ã€‚");
          return;
        }
        const key = canonicalUrl(item.url);
        const current = state.statusMap[key] || {};
        const payload = { chat_id: state.chatId, url: item.url };
        if (current.taskId){
          payload.task_code = current.taskId;
        }
        const btn = card.querySelector(".btn-stop");
        const original = btn ? btn.textContent : "";
        if (btn){
          btn.disabled = true;
          btn.textContent = "é€å‡ºä¸­â€¦";
        }
        setCardFeedback(feedback, "é€å‡ºåœæ­¢ç›£çœ‹è«‹æ±‚ä¸­â€¦");
        try {
          const res = await fetch(`${API_ROOT}/unwatch`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            credentials: "include",
            body: JSON.stringify(payload),
          });
          const body = await res.json();
          if (!res.ok){
            throw new Error(body.error || `HTTP ${res.status}`);
          }

          if (!body.ok && body.reason === "no_watch"){
            updateWatchState(item.url, { watching: false, enabled: false, taskId: current.taskId || null, found: false });
            updateCardWatchInfo(item.url, watchInfo);
            setCardFeedback(feedback, body.message || "æ­¤æ´»å‹•ç›®å‰æ²’æœ‰ç›£çœ‹ä»»å‹™ã€‚");
            alert(body.message || "æ­¤æ´»å‹•ç›®å‰æ²’æœ‰ç›£çœ‹ä»»å‹™ã€‚");
            return;
          }
          if (!body.ok){
            throw new Error(body.error || body.message || `HTTP ${res.status}`);
          }
          updateWatchState(item.url, { watching: false, enabled: false, taskId: body.task_id || current.taskId, found: true });
          updateCardWatchInfo(item.url, watchInfo);
          const stopMessage = body.message === "stopped" ? "å·²åœæ­¢ç›£çœ‹ã€‚" : (body.message || "å·²åœæ­¢ç›£çœ‹ã€‚");
          setCardFeedback(feedback, stopMessage);
          if (body.detail){
            statusText.textContent = buildStatusLine({
              remain: body.detail.remain ?? body.detail.remaining,
              status_text: body.detail.status_text,
            });
          }

        } catch (err) {
          console.error("unwatch failed", err);
          alert(`åœæ­¢ç›£çœ‹å¤±æ•—ï¼š${err.message || err}`);
          setCardFeedback(feedback, "åœæ­¢ç›£çœ‹å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚");
        } finally {
          if (btn){
            btn.disabled = false;
            btn.textContent = original || "â›”ï¸ åœæ­¢ç›£çœ‹";

          }
        }
      }

      async function handleQuickCheck(item, card, statusText, feedback){
        if (!item.url){
          alert("æ­¤æ´»å‹•æ²’æœ‰å¯ç”¨çš„ URLã€‚");
          return;
        }
        setButtonsDisabled(card, true);
        setCardFeedback(feedback, "å¿«é€ŸæŸ¥çœ‹ä¸­â€¦");
        try {
          const res = await fetch(`${API_ROOT}/quick-check`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            credentials: "include",
            body: JSON.stringify({ url: item.url }),
          });
          const body = await res.json();
          if (!res.ok || !body.ok){
            throw new Error(body.error || `HTTP ${res.status}`);
          }

          const detail = body.detail || {};
          if (detail){
            statusText.textContent = buildStatusLine({
              remain: body.remain ?? detail.remain ?? detail.remaining,
              status_text: body.status_text || detail.status_text,
            });
          }
          setCardFeedback(feedback, body.message || "å·²å–å¾—æœ€æ–°ç¥¨æ•¸è³‡è¨Šã€‚");

          if (body.message){
            if (state.isClient){
              try {
                await liff.sendMessages([{ type: "text", text: body.message }]);
              } catch (e) {
                console.warn("sendMessages failed", e);
              }
            }
            alert(body.message);
          }
        } catch (err) {
          console.error("quick-check failed", err);
          alert(`å¿«é€ŸæŸ¥çœ‹å¤±æ•—ï¼š${err.message || err}`);
          setCardFeedback(feedback, "å¿«é€ŸæŸ¥çœ‹å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚");
        } finally {
          setButtonsDisabled(card, false);
        }
      }

      async function fetchConcerts(mode){
        const url = new URL(`${API_ROOT}/concerts`, window.location.origin);
        url.searchParams.set("mode", mode);
        url.searchParams.set("limit", String(LIMIT));
        const res = await fetch(url.toString(), { credentials: "include" });
        if (!res.ok){
          const text = await res.text();
          throw new Error(`HTTP ${res.status} ${text}`);
        }
        return res.json();
      }

      async function fetchWatchStatus(chatId, urls){
        if (!chatId || !Array.isArray(urls) || urls.length === 0) return {};
        const unique = [];
        const seen = new Set();
        urls.forEach((raw) => {
          if (typeof raw !== "string") return;
          const val = raw.trim();
          if (!val || seen.has(val)) return;
          seen.add(val);
          unique.push(val);
        });
        if (!unique.length) return {};
        const res = await fetch(STATUS_API, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          credentials: "include",
          body: JSON.stringify({ chatId, urls: unique }),
        });
        if (!res.ok){
          throw new Error(`HTTP ${res.status}`);
        }
        const body = await res.json();
        return body && body.results ? body.results : {};
      }

      function render(items){
        if (!elList) return;
        elList.innerHTML = "";
        if (!Array.isArray(items) || items.length === 0){
          const empty = document.createElement("div");
          empty.className = "empty-message";
          empty.textContent = "ç›®å‰æŠ“ä¸åˆ°æ´»å‹•æ¸…å–®ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚";
          elList.appendChild(empty);
          return;
        }
        items.forEach((item, idx) => {
          const card = createCard(item, idx);
          elList.appendChild(card);
        });
      }

      async function loadConcerts(){
        if (state.loading) return;
        state.loading = true;
        setStatus("è¼‰å…¥æ´»å‹•æ¸…å–®ä¸­â€¦");
        try {
          let data = await fetchConcerts("carousel");
          let items = Array.isArray(data.items) ? data.items : [];
          let sourceMode = data && data.mode ? data.mode : "carousel";
          if (!items.length){
            const fallback = await fetchConcerts("all");
            if (fallback && Array.isArray(fallback.items) && fallback.items.length){
              data = fallback;
              items = fallback.items;
              sourceMode = fallback.mode || "all";
            }
          }

          state.items = items;
          const urls = items.map(it => it.url).filter(Boolean);
          try {
            const statusMapRaw = await fetchWatchStatus(state.chatId, urls);
            state.statusMap = {};
            Object.keys(statusMapRaw).forEach((key) => {
              const entry = statusMapRaw[key];
              state.statusMap[canonicalUrl(key)] = entry;
            });
          } catch (e){
            console.warn("fetchWatchStatus failed", e);
          }
          render(items);
          setStatus(items.length ? `å…± ${items.length} ç­†æ´»å‹•${sourceMode === "all" ? "ï¼ˆä½¿ç”¨å‚™æ´è³‡æ–™ï¼‰" : ""}` : "ç›®å‰æŠ“ä¸åˆ°æ´»å‹•æ¸…å–®ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚");
        } catch (err) {
          console.error("loadConcerts failed", err);
          setStatus(`è¼‰å…¥å¤±æ•—ï¼š${err.message || err}`);
          elList.innerHTML = "";
          const empty = document.createElement("div");
          empty.className = "empty-message";
          empty.textContent = "ç›®å‰æŠ“ä¸åˆ°æ´»å‹•æ¸…å–®ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚";
          elList.appendChild(empty);
        } finally {
          state.loading = false;
        }
      }

      async function resolveChatId(){
        if (!window.liff) return null;
        if (!state.isClient) {
          try {
            const profile = await liff.getProfile();
            if (profile && profile.userId) return profile.userId;
          } catch (e) {
            console.warn("getProfile failed", e);
          }
          return null;
        }
        try {
          const ctx = liff.getContext();
          if (ctx){
            if (ctx.type === "group" && ctx.groupId) return ctx.groupId;
            if (ctx.type === "room" && ctx.roomId) return ctx.roomId;
            if (ctx.userId) return ctx.userId;
          }
        } catch (e) {
          console.warn("getContext failed", e);
        }
        try {
          const profile = await liff.getProfile();
          if (profile && profile.userId) return profile.userId;
        } catch (e) {
          console.warn("getProfile failed", e);
        }
        return null;
      }

      async function init(){
        if (!window.liff){
          setStatus("æ‰¾ä¸åˆ° LIFF SDKï¼Œè«‹ç¨å¾Œå†è©¦ã€‚");
          return;
        }
        setStatus("åˆå§‹åŒ– LIFF ä¸­â€¦");
        try {
          if (LIFF_ID){
            await liff.init({ liffId: LIFF_ID });
          } else {
            await liff.init({});
          }
          state.isClient = liff.isInClient();
        } catch (err) {
          console.error("liff.init failed", err);
          setStatus("LIFF åˆå§‹åŒ–å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚");
          return;
        }

        try {
          state.chatId = await resolveChatId();
        } catch (e){
          console.warn("resolveChatId failed", e);
        }

        if (elReload){
          elReload.addEventListener("click", () => {
            loadConcerts();
          });
        }

        loadConcerts();
      }

      document.addEventListener("DOMContentLoaded", init);
    })();
  </script>

</body>
</html>
